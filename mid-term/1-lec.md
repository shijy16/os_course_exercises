# lec1

CR0 控制寄存器

CR2 页访问异常地址

CR3 页目录表基址

GDTR GDT基址

##### 操作系统内核的特征

+ 并发
  + 计算机系统中同时存在多个运行的程序，需要OS管理和调度
  + （并行:多个内核同时处理一个任务)
+ 共享
  + "同时访问"，互斥共享
+ 虚拟
  + 利用多道程序设计技术，让每个欧诺个户都觉得有一个计算机专门为他服务
+ 异步
  + 应用程序发起调用后不进行等待，直接进入下一步

##### 操作系统历史

+ 单用户系统
+ 批处理系统：顺序执行多个任务
+ 多道程序系统：可以在内存中保存多个工作，并且在工作间共享CPU
+ 分时系统：按时间片分配CPU资源给用户
+ 分布式操作系统

##### 操作系统结构

+ 简单结构：没有拆分为模块
+ 分层结构：分为多层（硬件层....用户界面），每一层仅使用更低一层的功能和服务
+ UNIX操作系统：可移植操作系统，高级语言
+ 微内核结构：尽可能把内核功能移到用户空间。灵活安全，但性能不好

# lec2

特权指令：CPL=0时才能执行的指令

# lec3 启动 中断/异常/系统调用

## 启动

CPU初始化->BIOS->MBR->分区引导扇区->加载程序->OS

#### 启动前的准备

+ CPU状态寄存器初始化
+ MMU/TLBs初始化为无效值
+ 其他寄存器赋初值
+ CP0寄存器初始化
+ 硬件初始化的最主要工作是<u>内存控制器</u>的初始化
+ 加载OS,跳转到OS入口

#### 启动时

CS:IP=0xffff0，第一条指令从这里执行

地址空间为20位

#### BIOS

##### BIOS功能

+ 以中断调用的方式提供了基本I/O
+ 从磁盘的引导扇区（MBR）加载加载程序到0x7c00，跳转到0x7c00

##### BIOS初始化过程

+ 硬件自检POST
+ 初始化服务功能，设置硬件中断号
+ 加载引导扇区

#### 主引导记录MBR

+ 启动代码：检查分区表，加载并跳转到磁盘上的引导程序
+ 硬盘分区表
+ 结束标志字 0x55AA

#### 分区引导扇区

+ 跳转到启动代码
+ 文件卷头结构：文件系统描述信息
+ 启动代码：跳转到加载程序
+ 结束标志字 0x55AA

#### 加载程序

+ 从文件系统中读取配置信息
+ 启动菜单（配置系统内核列表和加载参数）
+ 根据配置加载指定内核表跳转到内核

## 异常/中断/系统调用

异常：需要操作系统处理应用程序出现的错误

中断：外设通过中断机制获得CPU响应

系统调用：应用程序不值得信任，直接访问系统应用不安全

不同之处：源头、响应方式（异步同步）、处理机制（异常杀死或重新执行，中断持续透明，调用等待和持续，支持异步）。

### 异常

最多嵌套两层

### 中断

80386通过INTR和NMI接受外部中断请求信号，前者可屏蔽，后者不可屏蔽，EFLAGS寄存器中IF标志决定是否屏蔽可屏蔽中断请求

中断向量表的建立和初始化是由BIOS在计算机启动时完成，计算机启动后，操作系统和用户程序根据自己的需要修改某些中断的入口地址

加电以后,BIOS初始化完毕，中断向量表还没建立，但外部设备已经初始化，此时发生中断会被CPU屏蔽，cpu中有一个中断屏蔽字可以屏蔽中断

##### 硬件处理

+ 设置中断屏蔽标志
+ 保存现场
+ 查找向量表并跳转

中断处理时出现的中断会被临时禁止，请求会保持到CPU做出响应

### 系统调用

INT RET 需要切换堆栈和特权级



# lec4 lab1

## x86启动顺序

IDT 中断向量表

GDT 全局描述符表（段表）

### BIOS

4G空间`FFFC00000h~FFFFFFFFh`和`E0000~FFFFF`之间的请求都会导向BIOS

+ POST自检
+ 加载MBR到0x7c00并跳转

### bootloader

+ 使能保护模式和段机制
  + 保护模式：CR0的bit0（PE位）
  + 段机制：保护模式下自动使能
+ 读取ucore kernel
+ 跳转到OS的入口

### 实模式

寻址：物理地址=段基地址*4+段内偏移

#### 中断响应

##### 硬件

+ 取得中断类型
+ 保存现场`（TF=0,IF=0，CS,IP,IP=N*4,CS=N*4+2)`
+ 跳转到终端服务例程

##### 软件

+ 保存要用的寄存器
+ 处理中断
+ 恢复要用到的寄存器
+ iret返回

### C函数调用

32位x86使用栈传参：因为寄存器数目少

64位x86使用前六个寄存器传参

EBP：当前函数的栈底，指向caller的EBP

##### 函数调用栈

临时存储

本地变量

EBP:调用者EBP地址

返回地址

参数

调用者保存的寄存器

## x86中断处理

### 确定中断服务例程

中断号查IDT->段选择子+offset

查GDT->base address+offset

##### 硬件

查IDT/GDT,跳转

保存SS,ESP,EFLAGS,CS,EIP,ERROR CODE

同一特权级不需要保存SS和ESP

##### 软件

保存用到的寄存器