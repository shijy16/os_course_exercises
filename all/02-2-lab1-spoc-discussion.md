# lec4: lab1 SPOC思考题

##**提前准备**
（请在上课前完成）

 - 完成lec4的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
 - 了解x86的保护模式，段选择子，全局描述符，全局描述符表，中断描述符表等概念，以及如何读写，设置等操作
 - 了解Linux中的ELF执行文件格式
 - 了解外设:串口，并口，时钟，键盘,CGA，已经如何对这些外设进行编程
 - 了解x86架构中的mem地址空间和io地址空间
 - 了解x86的中断处理过程（包括硬件部分和软件部分）
 - 了解GCC的x86/RV内联汇编
 - 了解C语言的可函数变参数编程
 - 了解qemu的启动参数的含义
 - 在piazza上就lec3学习中不理解问题进行提问
 - 学会使用 qemu
 - 在linux系统中，看看 /proc/cpuinfo的内容

## 思考题

### <u>启动顺序</u>

1. x86段寄存器的字段含义和功能有哪些？

+ DS 数据段寄存器：当前程序存放数据段的段基址。
+ CS 代码段寄存器：当前程序代码段的段基址。
+ SS 堆栈段寄存器：当前堆栈栈底地址，即堆栈段段基址。
+ ES 附加段寄存器：当前程序使用附加数据段的段基址。
+ FS 附加段寄存器：同ES
+ GS 附加段寄存器：同ES

2. x86描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？

段选择子存在于段寄存器中，用来从符表中读取正确的表项获取基地址。

+ DPL：
  + 含义：访问该段所需要的特权级
  + 存在于段描述符中
+ CPL:
  + 含义：当前程序的特权级。
  + 存在于CS中低两位。
+ RPL：
  + 含义：程序访问某段时所请求的特权级，一般大于等于CPL
  + 存在于段选择子中？？



3. 分析可执行文件格式elf的格式（无需回答）

### 4.1 C函数调用的实现

### 4.2 x86中断处理过程

1. x86/RV中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？
   1. 压栈内容：eflags，cs，eip，（errorCode）
   2. 用户态中断需要切换特权级，还需要压栈SS(堆栈寄存器）和ESP（栈顶）
2. 为什么在用户态的中断响应要使用内核堆栈？
   1. 保证中断服务例程的代码安全
3. x86中trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?
   1. 区别：当调用Interrupt Gate时，Interrupt会被CPU自动禁止；而调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子。
   2. 后果：发生Interrupt时可能重复触发中断，导致中断服务例程在还没有准备好的时候再次被触发，造成错误，Interrupt类型中断会在准备好接受嵌套中断后取消禁止。

> interrupt 是中断用到
>
> trap 是系统调用用到
>
> 【补充】所谓“自动禁止”，指的是CPU跳转到interrupt gate里的地址时，在将EFLAGS保存到栈上之后，清除EFLAGS里的IF位，以避免重复触发中断。在中断处理例程里，操作系统可以将EFLAGS里的IF设上,从而允许嵌套中断。但是必须在此之前做好处理嵌套中断的必要准备，如保存必要的寄存器等。二在ucore中访问Trap Gate的目的是为了实现系统调用。用户进程在正常执行中是不能禁止中断的，而当它发出系统调用后，将通过Trap Gate完成了从用户态（ring 3）的用户进程进了核心态（ring 0）的OS kernel。如果在到达OS kernel后禁止EFLAGS里的IF位，第一没意义（因为不会出现嵌套系统调用的情况），第二还会导致某些中断得不到及时响应，所以调用Trap Gate时，CPU则不会去禁止中断。总之，interrupt gate和trap gate之间没有优先级之分，仅仅是CPU在处理中断时有不同的方法，供操作系统在实现时根据需要进行选择。

### 4.3 练习四和五 ucore内核映像加载和函数调用栈分析

1. ucore中，在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？
   1. `read_ebp`可以通过汇编指令直接得到，所以可以内联，而且在发生函数调用时`ebp`会改变。
   2. `read_eip`不能通过汇编指令直接得到，只能通过函数调用将其压栈然后从栈中获得

### 4.4 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？
   1. 不是。因为加电初始化后还没有在内存中建立中断向量表和存储中断服务程序。它们会在POST自检完成后建立

## 开放思考题

1. 在ucore/rcore中如何修改lab1, 实现在出现除零异常时显示一个字符串的异常服务例程？
2. 在ucore lab1/bin目录下，通过`objcopy -O binary kernel kernel.bin`可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)
3. GRUB是一个通用的x86 bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)
4. 如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？

## 课堂实践
### 练习一
在Linux系统的应用程序中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。

### 练习二
在ucore/rcore内核中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。
