# lec5 连续内存管理

+ 抽象
  + 逻辑地址空间 **自己拥有的内存空间是连续的**
+ 保护
  + 硬件机制上隔离应用程序的地址空间
+ 共享
  + 应用程序能够访问相同内存
+ 虚拟化
  + 更大的地址空间

##### 逻辑地址生成

编译->汇编->链接->程序加载（重定位 仍然使用逻辑地址）

### 缺点

+ 物理内存必须连续
+ 存在外碎片和内碎片
+ 内存分配的动态修改困难
+ 内存利用率较低

## 连续内存分配

+ 内存碎片
+ 内部碎片
+ 外部碎片

动态分区分配：当程序被加载执行时，分配一个进程指定大小可变的分区，分区地址连续

操作系统需要维护：空闲分区和进程已分配分区数据结构

##### 最先匹配

满足要求的第一块，按需求切分

释放时合并相邻块

+ 优点
  + 简单
  + 高地址大块空闲
+ 缺点
  + 外部碎片
  + 分配大块慢

##### 最佳匹配

使用满足要求的最小分区

空闲分区表按大小排序

释放时合并

+ 优点
  + 大部分尺寸小时效果好
    + 减小外部碎片大小
    + 简单
    + 避免大分区被拆分
+ 缺点
  + 外部碎片
  + 释放慢
  + 产生无用小碎片

##### 最差匹配

使用满足要求的最大分区

列表从大到小排序

释放时合并

+ 优点
  + 中等大小多时效果好
  + 避免小碎片多
+ 缺点
  + 释放慢
  + 外部碎片
  + 后期难以分配大分区

## 碎片整理

调整进程占用的分区位置来减少碎片

### 紧凑

移动进程的内存分区来合并外部碎片

+ 条件
  + 所有应用程序可以动态重定位

### 分区对换

把处于等待状态的进程分区放进外存

## 伙伴系统

先找最小可用的，如果最小的过大，二分直到合适



# lec6 非连续内存

允许使用非连续物理地址空间

允许共享代码和数据

支持动态加载和动态链接

## 段地址空间

段概念：

+ 表示访问和存储数据等属性相同的一段地址空间



## 页机制

页号：页内偏移 虚拟地址

帧号：帧内偏移 物理地址

帧大小和页大小必须相同

页表项标志位：存在位、修改位、引用位。由硬件设置

CR0的bit31为使能位

### TLB

使用关联存储实现

未命中则立即更新

+ 缓解页表占用空间过大问题
+ 使用页号并发查找表项

X86不产生TLB缺失异常，直接硬件实现缺失后查找页表

多核条件会产生大量缺失

### 多级页表

### 页寄存器

*为了解决逻辑地址空间越来越大导致页表越来越大，而物理地址空间相对较小的问题，页寄存器和反置页表让页表和物理地址空间的大小相对应*

每个帧和一个页寄存器关联，寄存器内容包括使用位、页号、保护位。每一个帧都要有一个页寄存器对应

### 反置页表

HASH（页号+进程号）来索引页表项，然后判等，确保没有哈希冲突

## 段页式

通过共享段来实现进程间共享内存

每个段加一级页表

# lec7 lab2

### 段选择子

INDEX:15-3

TI:2

RPL:1-0

RPL：请求特权级

### 段描述符

DPL：段本身特权级

### 门描述符

DPL：段本身特权级

CPL在段寄存器CS中

RPL在段寄存器DS,ES,FS,GS,SS中